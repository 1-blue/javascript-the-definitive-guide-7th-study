# Chapter 8. 함수

> [Blog Post](https://velog.io/@husbumps/javascript-the-definitive-guide-7e-chapter-8)

<br>

[1. Function Definition - 함수 정의](#1-function-definition---함수-정의)  
[2. 함수 호출](#2-함수-호출)  
[3. Default Parameters](#3-default-parameters)  
[4. Rest Parameters, Arguments](#4-rest-parameters-arguments)  
[5. Arrow Function - 화살표 함수](#5-arrow-function---화살표-함수)  
[6. Execution Context - 실행컨텍스트](#6-execution-context---실행컨텍스트)  
[7. This](#7-this)  
[8. Namespac, IIFE - 네임스페이스, IIFE](#8-namespac-iife---네임스페이스-iife)  
[9. Closure - 클로저](#9-closure---클로저)

<br>

## 1. Function Definition - 함수 정의

- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 입력을 받아서 출력을 한다.
  - 입력을 전달받는 변수 : `Parameters - 매개변수`
  - 입력된 값 : `Argument - 인수`
  - 출력 값: `Return Value`
- 함수는 객체다.
  - 프로퍼티와 프로토타입을 가진다.
- 함수는 `Function Definition`로 생성한다.
  - 4가지 방법: `함수 선언문`, `함수 표현식`, `화살표 함수`, `생성자 함수`

<br>

### 함수 선언문

- 함수 이름을 생략할 수 없다.
- 함수 이름은 소문자로 시작한다.

```js
function doSomething(a, b, c) {
  return a + b + c;
}
```

- 함수 선언문은 실제로는 함수 이름과 같은 식별자를 만들어 할당한다.
  - 함수 이름으로 호출하는 것이 아니라 함수를 가리키는 식별자로 호출하는 것이다.
- 함수 선언문으로 정의하면 식별자 변수는 호이스팅된다.
  - 선언문 이전에 참조, 호출이 가능하다.

```js
doSomething(1, 2, 3); // 호이스팅

var doSomething = function doSomething(a, b, c) {
  return a + b + c;
};
```

<br>

### 함수 표현식

#### 익명함수

- 할당한 변수명이 함수 이름이 된다.

```js
doSomething(1, 2, 3); // EReferenceError: doSomething is not defined

const doSomething = function (a, b, c) {
  return a + b + c;
};

doSomething(1, 2, 3); // 6
doSomething.name; // 'doSomething'
```

#### 기명함수

- 함수 이름으로 호출할 수 없다.

```js
const doSomething = function func(a, b, c) {
  return a + b + c;
};

doSomething(1, 2, 3); // 6
console.log(doSomething.name); // 'func'
func(1, 2, 3); // ReferenceError: func is not defined
```

<br>

### 생성자 함수

- new 연산자와 함께 호출한다.
- 생성자의 프로토타입 프로퍼티에서 지정된 객체를 상속하는 빈 객체를 새로 생성한다.

```js
function Person(nickname, age) {
  this.nickname = nickname;
  this.age = age;
  this.sleep = function () {
    console.log(`${this.nickname} is sleeping`);
  };
}

const sangbeomheo = new Person('husbumps', 15);

sangbeomheo.nickname; // husbumps
sangbeomheo.age; // 15
sangbeomheo.sleep(); // husbumps is sleeping
```

### 화살표 함수

- [밑에서 다루겠다.]()

<br>

## 2. 함수 호출

- 함수로 호출 : `func(1,2,3)`
- 메서드로 호출 : `obj.method(1,2,3)`
- 생성자로 호출 : `new Person(1,2,3)`
- 간접적 호출 (call, apply) : `func.call(thing)`

<br>

- 함수를 호출할 때 매개변수의 타입을 따로 지정하지 않아도 된다.
- 매개변수에 값이 들어오지 않았다면(인자가 없다면) 해당 변수는 `undefined`가 된다.

<br>
<hr>

## 3. Default Parameters

- ES6 추가
- 매개변수를 작성할 때 기본 값을 할당할 수 있다.
- 인수가 전달되지 않은 경우, undefined인 경우에 할당한 기본 값이 인수가 된다.

```js
function sum(x = 0, y = 0) {
  // Default Parameters가 없을 때는 이렇게 직접 체크를 해줬다.
  // x = x || 0;
  // y = y || 0;
  return x + y;
}

sum(10); // 10 + 0 = 10
sum(); // 0 + 0 = 0
```

<br>

## 4. Rest Parameters, Arguments

- ES6에서 `Rest Parameters` 추가
- `Rest Parameters`를 사용하면 매개변수의 개수가 동적일 때 인수 목록을 배열로 전달받을 수 있다.
- `arguments`가 갖은 문제점과 번거로움을 보완
  - `arguments`는 유사배열이라서 배열 메소드를 사용하려면 배열로 변환해줘야한다.
  - 화살표 함수는 `arguments` 객체를 갖지 않는다.

```js
function sum(...numbers) {
  console.log(numbers); // Array(5) [1,2,3,4,5]
  console.log(arguments); // Arguments(5) [1,2,3,4,5]
  return numbers.reduce((a, c) => a + c);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

<br>

### 객체, 배열 분해해 매개변수로 사용할 수 있다.

```js
function sum(...numbers) {
  console.log(numbers); // Array(5) [1,2,3,4,5]
  return numbers.reduce((a, c) => a + c);
}

const arr = [1, 2, 3, 4, 5];
console.log(sum(...arr)); // 15
```

<br>

## 5. Arrow Function - 화살표 함수

- function 키워드 대신 화살표 `=>` 를 사용해 함수를 정의한다.
- 내부 동작이 기존의 함수보다 간략하다.
- 함수 선언문으로 정의할 수 없고 표현식으로만 정의해야 한다.

```js
const sum = (x, y) => {
  return s + y;
};

const sum = (x, y) => s + y; // {}를 생략할 수 있다. 이 경우 'return'도 생략
```

<br>

### 화살표 함수 vs 일반 함수

- 화살표 함수는 인스턴스를 생성할 수 없다. `non-constuctor`

```js
const Arrow = () => {};
new Arrow(); // TypeError: Arrow is not a constructor
```

- this, arguments, super, new.target 바인딩을 갖지 않는다.
  - 스코프 체인 상 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 this, arguments, super, new,target을 참조한다.

```js
// Arguments

function outer(a, b, c) {
  console.log(arguments); // 1

  function inner1(a, b, c) {
    console.log(arguments); // 2
  }

  const inner2 = (a, b, c) => {
    console.log(arguments); // 3
  };

  inner1(4, 5, 6);
  inner2(7, 8, 9);
}

outer(1, 2, 3);

// 1 [Arguments] { '0': 1, '1': 2, '2': 3 }
// 2 [Arguments] { '0': 4, '1': 5, '2': 6 }
// 3 [Arguments] { '0': 1, '1': 2, '2': 3 } // 상위함수 바인딩
```

<br>

## 6. Execution Context - 실행컨텍스트

<br>

## 7. This

**This Binding은 실행컨텍스트가 활성화될 때 한다!**

⇒ 실행 컨텍스트가 생성되는 순간에 this를 binding 한다.
⇒ 실행 컨텍스트는 언제 생성? 컨텍스트에 해당하는 `**함수가 호출되는 순간!!`

함수를 어떤 식으로 호출했느냐에 따라서 this가 결정된다.\*\*

### **전역공간에서 `this`**

전역공간에서의 `**this**` 는 `**전역 객체**`를 가리킨다.

- window(document) / global(node)
- 자바스크립트를 실행하는 환경에 따라 달라진다.

```jsx
// 브라우저에서
console.log(this); // Window {...}

var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a); // 1

// node.js에서
console.log(this); // Object [global] {...}
```

### 함수 호출 시 **`this`**

함수 호출은 전역객체가 하기때문에 `**this**` 는 `**전역 객체**`를 가리킨다.

함수를 실행하는 순간에 함수를 실행해주는 주체는? ⇒ 전역 객체
함수호출시 this는 언제나 전역 객체를 가리킨다.

- ES6에서 ThisBinding을 하지 않는 `arrow function` 이 나옴

```jsx
function a() {
  console.log(this);
}
a(); // ?

function b() {
  function c() {
    console.log(this);
  }
  c(); // ?
}

b(); // ?
```

```jsx
const outer = {
  inner: function () {
    function innerFunc() {
      console.log(this); //
    }
    innerFunc();
  },
};
outer.inner();
```

### 메서드 호출 시 **`this`**

`메서드를 호출한 주체`가 `this`가 된다.

- `.` 앞이 `this`!
- 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행
- 클래스, 인스턴스도 객체이기 때문에 똑같이 동작한다.
- 함수인데, 어떤 객체와 관련된 동작을 하게 되면 메서드가 된다.

```jsx
var func = function (x) {
  console.log(this, x);
};
func(1); //

var obj = {
  method: func,
};
obj.method(2); //
obj['method'](2); //

// 익명함수는 그대로인데 이를 변수에 담아 호출한 경우,
// obj객체의 프로퍼티에 할당해서 메소드로 호출한 경우
// 에 따라 this가 달라진다.
```

```jsx
const outer = {
  inner: function () {
    console.log(this);

    function innerFunc() {
      console.log(this);
    }
    innerFunc();
  },
};
outer.inner();
```

```jsx
const a = {
  b: {
    c: function () {
      console.log(this);
    },
  },
};
a.b.c(); // {c: f}

// c함수에게 a.b와 관련된 동작을 수행해라.
```

- 메서드 내부함수에서의 우회법
  - [스코프 체인](https://velog.io/@oneook/%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-JavaScript-Basics)을 생각해보자!

```jsx
var a = 10;

const obj = {
  a: 20,
  b: function () {
    console.log(this.a); // 20

    function c() {
      console.log(this.a); // 10
    }
    c();
  },
};
obj.b();

// 둘 다 20이 나오게 하려면? (c함수에서 this가 b를 가리키게 하려면)
```

- 아예 다른 변수를 사용
- 화살표 함수 사용 (ES6)
- `call`, `apply`, `bind` 를 사용 (ES5)

```jsx
// 아예 다른 변수를 사용
// 화살표 함수가 생기면서 더이상 필요 없어짐

var a = 10;

const obj = {
  a: 20,
  b: function () {
    var _this = this;
    console.log(this.a); // 20

    function c() {
      console.log(_this.a); // 20
    }
    c();

    const _c = () => {
      console.log(this.a); // 20
    };
    _c();
  },
};
obj.b();
```

### **call, apply, bind 메소드**

- this를 명시적으로 바인딩하는 3가지 방법

```jsx
function example(a, b, c) {
  console.log(this, a, b, c); // window, 1, 2, 3
}

const obj = {
  x: 'x',
};

example(1, 2, 3);

example.call(obj, 1, 2, 3);
example.apply(obj, [1, 2, 3]);

const boundExample1 = example.bind(obj);
boundExample1(1, 2, 3);

const boundExample2 = example.bind(obj, 1, 2);
boundExample2(3);
```

### callback 호출시 **`this`**

\*\*기본적으로는 `함수내부에서와 동일` ⇒ this는 `전역객체`

콜백함수를 넘겨받은 대상이 해당 콜백함수를 어떻게 처리하느냐에 따라서 다르다.\*\*

- **callback 함수란 ?**
  - 다른 코드의 인자로 넘겨주는 함수
  - 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다.
  - 함수의 제어권을 넘겨주는 것
  - ex) 알람시계 - 특정시점에 알람을 울려라!(함수)

```jsx
// 콜백함수의 대표적인 예) setTimeout, setInterval ...

setTimeout(() => console.log('2초'), 2000);
setTimeout(() => console.log('1초'), 1000);
```

```jsx
const callback = function () {
  console.log(this);
};

const obj = {
  a: 1,
  b: function (fn) {
    fn();
  },
};

obj.b(callback); // ??
```

- 이벤트핸들러의 경우

```jsx
function b() {
  console.log(this);
}

document.body.innerHTML = '<div id="a">Hello</div>';

document.querySelector('#a').addEventListener('click', function () {
  console.log(this);
});

// 이벤트리스너 함수는 콜백함수를 실행할 때 이벤트가 발생한 타겟 엘리먼트로 한다고 정해져있음
```

### 생성자 함수로 호출시 **`this`**

새로 만드는 인스턴스 객체 그 자체가 `**this**`가 된다.

```jsx
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const sangbeomheo = Person('상범', 10);

console.log(sangbeomheo.name, sangbeomheo.age); // 상범, 10
```

<br>

## 8. Namespac, IIFE - 네임스페이스, IIFE

<br>

## 9. Closure - 클로저

<br>
<hr>

### 참고자료

- [자바스크립트 완벽 가이드 7판](https://product.kyobobook.co.kr/detail/S000001033131)
